rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Règles pour la collection signalements
    match /signalements/{signalementId} {
      allow read: if true;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null && 
        (request.auth.uid == resource.data.id_utilisateur || 
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin');
    }
    
    // Règles pour la collection photos
    match /photos/{photo} {
      allow read: if true;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null;
    }
    
    // Règles pour la collection login_attempts
    // Document id is the normalized email (lowercase, trimmed).
    match /login_attempts/{emailId} {
      // Allow reads so the client can check block status before sign-in.
      // Writes remain restricted to the authenticated owner.
      allow read: if true;

      // Allow the owner (authenticated) to create/update their document.
      // Also allow unauthenticated writes that include an `email` field matching
      // the document id — this enables the client to record failed attempts
      // before the user is signed in. In both cases we forbid setting
      // `disabled=true` from the client and ensure `attempts` is bounded.
      // TEMPORARY: permit any authenticated user to create/update their login_attempts
      // This relaxes the strict email matching checks to avoid permission-denied
      // errors during client-side recording of failed logins. Revert in prod.
      allow create, update: if (
        (request.auth != null)
        ||
        // Also allow unauthenticated writes when payload includes normalized email
        (request.auth == null && request.resource.data.email != null && request.resource.data.email.toLowerCase() == emailId)
      )
      // Prevent clients from setting disabled=true
      && ( !('disabled' in request.resource.data) || request.resource.data.disabled == false )
      // Ensure attempts is an integer within expected range
      && (request.resource.data.attempts is int)
      && request.resource.data.attempts >= 0
      && request.resource.data.attempts <= 3;

      // Disallow clients from deleting the document
      allow delete: if false;
    }
    
    // Règles pour la collection users
    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Règles pour la collection notifications
    match /notifications/{notification} {
      // TEMPORARY DEV: allow public reads to simplify client-side testing of
      // notification queries (including queries by id_avancement). Revert
      // this change before deploying to production.
      allow read: if true;
      allow create, update: if request.auth != null;
    }

    // Règles pour la collection avancement (historique des statuts)
    match /avancement/{change} {
      // TEMPORARY DEV: allow public read/create to simplify local testing.
      // Remove or tighten these rules before deploying to production.
      allow read: if true;
      allow create: if true;
      // TEMPORARY: allow the owner of the avancement or an admin to update it
      // so tests can modify existing avancement documents. Revert after testing.
      allow update: if request.auth != null && (
        request.auth.uid == resource.data.userId ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin'
      );
    }

    // Règles pour la collection statut_signallement (libellés de statuts)
    match /statut_signallement/{statutId} {
      // statuts lisibles par tous
      allow read: if true;
      // TEMPORARY DEV: allow authenticated writes for testing convenience.
      // In production, change back to require admin role.
      allow create, update: if request.auth != null;
    }
  }
}
